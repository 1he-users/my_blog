(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{270:function(t,_,e){"use strict";e.r(_);var s=e(0),i=Object(s.a)({},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),e("p",[t._v("在 TLS1.3 中废除了非常多的加密算法，最后只保留五个加密套件:")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),e("p",[t._v("我觉得有两方面的原因:")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),e("p",[t._v("流程如下:\n"),e("img",{attrs:{src:t.$withBase("/http/011.jpg")}})]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),e("p",[t._v("但这种方式也存在一个弊端，就是当客户端数量庞大的时候，对服务端的存储压力非常大。")]),t._v(" "),t._m(18),t._v(" "),e("p",[t._v("这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要定期进行更换。")]),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25)])},[function(){var t=this.$createElement,_=this._self._c||t;return _("h1",{attrs:{id:"_016-tls-1-3-做了哪些改进？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_016-tls-1-3-做了哪些改进？","aria-hidden":"true"}},[this._v("#")]),this._v(" 016: TLS 1.3 做了哪些改进？")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("p",[t._v("TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得更强的安全、更优秀的性能，在"),e("code",[t._v("2018年")]),t._v("就推出了 TLS1.3，对于"),e("code",[t._v("TLS1.2")]),t._v("做了一系列的改进，主要分为这几个部分:"),e("strong",[t._v("强化安全")]),t._v("、"),e("strong",[t._v("提高性能")]),t._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"强化安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强化安全","aria-hidden":"true"}},[this._v("#")]),this._v(" 强化安全")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ul",[e("li",[t._v("TLS_AES_128_GCM_SHA256")]),t._v(" "),e("li",[t._v("TLS_AES_256_GCM_SHA384")]),t._v(" "),e("li",[t._v("TLS_CHACHA20_POLY1305_SHA256")]),t._v(" "),e("li",[t._v("TLS_AES_128_GCM_SHA256")]),t._v(" "),e("li",[t._v("TLS_AES_128_GCM_8_SHA256")])])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("p",[t._v("可以看到，最后剩下的对称加密算法只有 "),e("strong",[t._v("AES")]),t._v(" 和 "),e("strong",[t._v("CHACHA20")]),t._v("，之前主流的也会这两种。分组模式也只剩下 "),e("strong",[t._v("GCM")]),t._v(" 和 "),e("strong",[t._v("POLY1305")]),t._v(", 哈希摘要算法只剩下了 "),e("strong",[t._v("SHA256")]),t._v(" 和 "),e("strong",[t._v("SHA384")]),t._v(" 了。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("那你可能会问了, 之前"),_("code",[this._v("RSA")]),this._v("这么重要的非对称加密算法怎么不在了？")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[_("strong",[this._v("第一")]),this._v("、2015年发现了"),_("code",[this._v("FREAK")]),this._v("攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[_("strong",[this._v("第二")]),this._v("、一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的"),_("code",[this._v("secret")]),this._v("，破解之前所有的密文。")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("p",[t._v("为什么？回到 RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成"),e("code",[t._v("pre_random")]),t._v("并用"),e("strong",[t._v("公钥")]),t._v("加密传给服务器，服务器通过"),e("strong",[t._v("私钥")]),t._v("解密，从而拿到真实的"),e("code",[t._v("pre_random")]),t._v("。当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到"),e("code",[t._v("pre_random")]),t._v("、"),e("code",[t._v("server_random")]),t._v("和"),e("code",[t._v("client_random")]),t._v("并根据对应的随机数函数生成"),e("code",[t._v("secret")]),t._v("，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("但"),_("code",[this._v("ECDHE")]),this._v("在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫"),_("strong",[this._v("前向安全性")]),this._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[_("code",[this._v("RSA")]),this._v(" 算法不具备前向安全性，而 "),_("code",[this._v("ECDHE")]),this._v(" 具备，因此在 TLS1.3 中彻底取代了"),_("code",[this._v("RSA")]),this._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"提升性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#提升性能","aria-hidden":"true"}},[this._v("#")]),this._v(" 提升性能")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"握手改进"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#握手改进","aria-hidden":"true"}},[this._v("#")]),this._v(" 握手改进")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到"),_("code",[this._v("client_params")]),this._v("，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算"),_("code",[this._v("secret")]),this._v("，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("这种 TLS 1.3 握手方式也被叫做"),_("strong",[this._v("1-RTT握手")]),this._v("。但其实这种"),_("code",[this._v("1-RTT")]),this._v("的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"会话复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#会话复用","aria-hidden":"true"}},[this._v("#")]),this._v(" 会话复用")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("会话复用有两种方式: "),_("strong",[this._v("Session ID")]),this._v("和"),_("strong",[this._v("Session Ticket")]),this._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("先说说最早出现的"),_("strong",[this._v("Seesion ID")]),this._v("，具体做法是客户端和服务器首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送"),_("code",[this._v("ID")]),this._v("过来，服务器查找这个 ID 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("因而出现了第二种方式——"),_("strong",[this._v("Session Ticket")]),this._v("。它的思路就是: 服务端的压力大，那就把压力分摊给客户端呗。具体来说，双方连接成功后，服务器加密会话信息，用"),_("strong",[this._v("Session Ticket")]),this._v("消息发给客户端，让客户端保存下来。下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("总的来说，这些会话复用的技术在保证"),_("code",[this._v("1-RTT")]),this._v("的同时，也节省了生成会话密钥这些算法所消耗的时间，是一笔可观的性能提升。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"psk"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#psk","aria-hidden":"true"}},[this._v("#")]),this._v(" PSK")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("刚刚说的都是"),_("code",[this._v("1-RTT")]),this._v("情况下的优化，那能不能优化到"),_("code",[this._v("0-RTT")]),this._v("呢？")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("答案是可以的。做法其实也很简单，在发送"),_("strong",[this._v("Session Ticket")]),this._v("的同时带上应用数据，不用等到服务端确认，这种方式被称为"),_("code",[this._v("Pre-Shared Key")]),this._v("，即 PSK。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("这种方式虽然方便，但也带来了安全问题。中间人截获"),_("code",[this._v("PSK")]),this._v("的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，增加了服务器被攻击的风险。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[this._v("#")]),this._v(" 总结")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("TLS1.3 在 TLS1.2 的基础上废除了大量的算法，提升了安全性。同时利用会话复用节省了重新生成密钥的时间，利用 PSK 做到了"),_("code",[this._v("0-RTT")]),this._v("连接。")])}],!1,null,null,null);_.default=i.exports}}]);