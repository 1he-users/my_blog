(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{273:function(t,_,e){"use strict";e.r(_);var s=e(0),i=Object(s.a)({},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),e("p",[t._v("HTTP/2 中传输的帧结构如下图所示:")]),t._v(" "),e("p",[e("img",{attrs:{src:t.$withBase("/http/010.png")}})]),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),e("p",[t._v("HTTP/2 其实也是借鉴了 TCP 状态变化的思想，根据帧的标志位来实现具体的状态改变。这里我们以一个普通的"),e("code",[t._v("请求-响应")]),t._v("过程为例来说明：\n"),e("img",{attrs:{src:t.$withBase("/http/012.jpg")}})]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),e("p",[t._v("以上就是对 HTTP/2 中二进制帧的介绍，希望对你有所启发。")])])},[function(){var t=this.$createElement,_=this._self._c||t;return _("h1",{attrs:{id:"_018-http-2-中的二进制帧是如何设计的？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_018-http-2-中的二进制帧是如何设计的？","aria-hidden":"true"}},[this._v("#")]),this._v(" 018: HTTP/2 中的二进制帧是如何设计的？")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"帧结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#帧结构","aria-hidden":"true"}},[this._v("#")]),this._v(" 帧结构")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("每个帧分为"),_("code",[this._v("帧头")]),this._v("和"),_("code",[this._v("帧体")]),this._v("。先是三个字节的帧长度，这个长度表示的是"),_("code",[this._v("帧体")]),this._v("的长度。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("然后是帧类型，大概可以分为"),_("strong",[this._v("数据帧")]),this._v("和"),_("strong",[this._v("控制帧")]),this._v("两种。数据帧用来存放 HTTP 报文，控制帧用来管理"),_("code",[this._v("流")]),this._v("的传输。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("接下来的一个字节是"),_("strong",[this._v("帧标志")]),this._v("，里面一共有 8 个标志位，常用的有 "),_("strong",[this._v("END_HEADERS")]),this._v("表示头数据结束，"),_("strong",[this._v("END_STREAM")]),this._v("表示单方向数据发送结束。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("后 4 个字节是"),_("code",[this._v("Stream ID")]),this._v(", 也就是"),_("code",[this._v("流标识符")]),this._v("，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"流的状态变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#流的状态变化","aria-hidden":"true"}},[this._v("#")]),this._v(" 流的状态变化")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("从前面可以知道，在 HTTP/2 中，所谓的"),_("code",[this._v("流")]),this._v("，其实就是二进制帧的"),_("strong",[this._v("双向传输的序列")]),this._v("。那么在 HTTP/2 请求和响应的过程中，流的状态是如何变化的呢？")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("p",[t._v("最开始两者都是空闲状态，当客户端发送"),e("code",[t._v("Headers帧")]),t._v("后，开始分配"),e("code",[t._v("Stream ID")]),t._v(", 此时客户端的"),e("code",[t._v("流")]),t._v("打开, 服务端接收之后服务端的"),e("code",[t._v("流")]),t._v("也打开，两端的"),e("code",[t._v("流")]),t._v("都打开之后，就可以互相传递数据帧和控制帧了。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("当客户端要关闭时，向服务端发送"),_("code",[this._v("END_STREAM")]),this._v("帧，进入"),_("code",[this._v("半关闭状态")]),this._v(", 这个时候客户端只能接收数据，而不能发送数据。")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("p",[t._v("服务端收到这个"),e("code",[t._v("END_STREAM")]),t._v("帧后也进入"),e("code",[t._v("半关闭状态")]),t._v("，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送"),e("code",[t._v("END_STREAM")]),t._v("帧，表示数据发送完毕，双方进入"),e("code",[t._v("关闭状态")]),t._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("如果下次要开启新的"),_("code",[this._v("流")]),this._v("，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2的 31 次方，大约 21 亿个。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"流的特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#流的特性","aria-hidden":"true"}},[this._v("#")]),this._v(" 流的特性")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("刚刚谈到了流的状态变化过程，这里顺便就来总结一下"),_("code",[this._v("流")]),this._v("传输的特性:")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ul",[e("li",[t._v("并发性。一个 HTTP/2 连接上可以同时发多个帧，这一点和 HTTP/1 不同。这也是实现"),e("strong",[t._v("多路")]),t._v("复用的基础。")]),t._v(" "),e("li",[t._v("自增性。流 ID 是不可重用的，而是会按顺序递增，达到上限之后又新开 TCP 连接从头开始。")]),t._v(" "),e("li",[t._v("双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为"),e("code",[t._v("发送方")]),t._v("或者"),e("code",[t._v("接收方")]),t._v("。")]),t._v(" "),e("li",[t._v("可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。")])])}],!1,null,null,null);_.default=i.exports}}]);